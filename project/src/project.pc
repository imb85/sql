#include <stdio.h>
#include <string.h>
#include <sqlca.h>
#include <stdlib.h>
#include <sqlda.h>
#include <sqlcpr.h>

#define STR_LEN 25 
 
typedef char asciiz[STR_LEN]; 

EXEC SQL TYPE asciiz IS CHARZ(STR_LEN) REFERENCE; 

asciiz username; 
asciiz password; 

struct customers {
	int customer_no;
	asciiz fname;
	asciiz lname;
	int house_no;
	asciiz street;
	asciiz city;
	asciiz state;
	asciiz phone;
	asciiz email;
};

struct vehicles {
	int customer_no;
	asciiz vin;
	int year;
	asciiz make;
	asciiz model;
	asciiz trim;
};

struct payments {
	int customer_no;
	int payment_no;
	asciiz card_no;
	asciiz ccv;
	asciiz exp;
};


struct orders {
	int order_no;
	asciiz vin;
	asciiz start_date;
	asciiz end_date;
	int employee_no;
	int odometer_in;
	int odometer_out;
};

struct invoices {
	int invoice_no;
	int customer_no;
	asciiz vin;
	int order_no;
	int employee_no;
	asciiz status;
	int balance;
	asciiz date_printed;
	asciiz date_paid;
};

struct employees {
	int employee_no;
	asciiz fname;
	asciiz lname;
	asciiz position;
	asciiz phone;
};

struct notes {
	int note_no;
	int order_no;
	asciiz description;
};

struct items {
	int item_no;
	int order_no;
	int procedure_no;
	asciiz description;
	int cost;
};

struct procedures {
	int procedure_no;
	int order_no;
	asciiz description;
	int cost;
};

void sql_error(char * msg){ 
	char err_msg[512];
	size_t buf_len, msg_len;

	EXEC SQL WHENEVER SQLERROR CONTINUE;

	printf("\n%s\n", msg);

	buf_len = sizeof(err_msg);
	sqlglm(err_msg, &buf_len, &msg_len);
	printf("%.*s\n", msg_len, err_msg);

	EXEC SQL ROLLBACK RELEASE;
	exit(EXIT_FAILURE);
} 

void main_menu(){
	printf("Select an option to query the database:\n");
	printf("0. Exit the program\n");
	printf("1. Add customer\n");
	printf("2. Delete employee\n");
}

void add_customer(){
	struct customers new_customer;

	printf("Enter customer_no >> ");
	scanf("%d", &new_customer.customer_no);
	printf("Enter fname >> ");
	scanf("%s", &new_customer.fname);
	printf("Enter lname >> ");
	scanf("%s", &new_customer.lname);
	printf("Enter house_no >> ");
	scanf("%d", &new_customer.house_no);
	printf("Enter street >> ");
	scanf("%s", &new_customer.street);
	printf("Enter city >> ");
	scanf("%s", &new_customer.city);
	printf("Enter state >> ");
	scanf("%s", &new_customer.state);
	printf("Enter phone >> ");
	scanf("%s", &new_customer.phone);
	printf("Enter email >> ");
	scanf("%s", &new_customer.email);

	EXEC SQL INSERT INTO  Customers (customer_no, fname, lname, house_no, street, city, state, phone, email)
	VALUES(:new_customer);
	EXEC SQL COMMIT;

	printf("New customer successfully added\n");
}

void delete_employee(){
	int e_no;
	
	printf("Enter employee_no >> ");
	scanf("%d", &e_no);

	EXEC SQL DELETE FROM Employees
	WHERE employee_no = :e_no;
	EXEC SQL COMMIT;

	printf("Employee successfully deleted\n");	
}

void main(){ 
	/* Connect to Oracle */ 
	strcpy(username, "abk89"); 
	strcpy(password, "~Ece3038");
	
	EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error: ");
 
	EXEC SQL CONNECT :username IDENTIFIED BY :password; 
	printf("\nConnected to Oracle as user: %s\n", username); 
 
	main_menu();

	while(1){
		int inp;
		printf(">> ");
		scanf("%d", &inp);

		switch(inp){
			case 0:
				printf("Program finished!\n");
				EXEC SQL COMMIT WORK RELEASE;
				exit(EXIT_SUCCESS);

			case 1:
				add_customer();
				break;
		
			case 2:
				delete_employee();
				break;

			case 3: 
				break;

			case 4:
				break;

			default:	
				printf("Invalid input \"%d\", please try again\n", inp);
				break;
		}
	}
} 


#include <stdio.h>
#include <string.h>
#include <sqlca.h>
#include <stdlib.h>
#include <sqlda.h>
#include <sqlcpr.h>

#define STR_LEN 25 
 
typedef char asciiz[STR_LEN]; 

EXEC SQL TYPE asciiz IS CHARZ(STR_LEN) REFERENCE; 

asciiz username; 
asciiz password; 

struct customer {
	int customer_no;
	asciiz fname;
	asciiz lname;
	int house_no;
	asciiz street;
	asciiz city;
	asciiz state;
	asciiz phone;
	asciiz email;
};

struct vehicle {
	int customer_no;
	asciiz vin;
	int year;
	asciiz make;
	asciiz model;
	asciiz trim;
};

struct payment {
	int customer_no;
	int payment_no;
	asciiz card_no;
	asciiz ccv;
	asciiz exp;
};


struct order {
	int order_no;
	asciiz vin;
	int start_date;
	int end_date;
	int employee_no;
};

struct invoice {
	int invoice_no;
	int customer_no;
	asciiz vin;
	int order_no;
	int employee_no;
	int odometer_in;
	int odometer_out;
	asciiz status;
	int balance;
	int date_printed;
	int date_paid;
};

struct employee {
	int employee_no;
	asciiz fname;
	asciiz lname;
	asciiz position;
	asciiz phone;
};

struct note {
	int note_no;
	int order_no;
	asciiz description;
};

struct item {
	int item_no;
	int order_no;
	int procedure_no;
	asciiz description;
	int cost;
};

struct procedure {
	int procedure_no;
	int order_no;
	asciiz description;
	int cost;
};

void sql_error(char * msg){ 
	char err_msg[512];
	size_t buf_len, msg_len;

	EXEC SQL WHENEVER SQLERROR CONTINUE;

	printf("\n%s\n", msg);

	buf_len = sizeof(err_msg);
	sqlglm(err_msg, &buf_len, &msg_len);
	printf("%.*s\n", msg_len, err_msg);

	EXEC SQL ROLLBACK RELEASE;
	exit(EXIT_FAILURE);
} 

void main_menu(){
	printf("Select an option to query the database:\n");
	printf(" 0. Exit the program\n");
	printf(" 1. Add customer\n");
	printf(" 2. Delete employee\n");
	printf(" 3. Update order description\n");
	printf(" 4. Show a vehicle's orders\n");
	printf(" 5. Show items for an invoice given an order\n");
	printf(" 6. Show orders completed June 2005 to December 2005\n");
	printf(" 7. Show items for a procedure\n");
	printf(" 8. Show number of proceudres for an order\n");
	printf(" 9. Show employee with higher than average number of invoices\n");
	printf("10. Invoice information\n");
}

// Query 1
// Completed
void add_customer(){
	struct customer new_customer;

	printf("Enter customer_no >> ");
	scanf("%d", &new_customer.customer_no);
	printf("Enter fname >> ");
	scanf("%s", &new_customer.fname);
	printf("Enter lname >> ");
	scanf("%s", &new_customer.lname);
	printf("Enter house_no >> ");
	scanf("%d", &new_customer.house_no);
	printf("Enter street >> ");
	scanf("%s", &new_customer.street);
	printf("Enter city >> ");
	scanf("%s", &new_customer.city);
	printf("Enter state >> ");
	scanf("%s", &new_customer.state);
	printf("Enter phone >> ");
	scanf("%s", &new_customer.phone);
	printf("Enter email >> ");
	scanf("%s", &new_customer.email);

	EXEC SQL INSERT INTO  Customers (customer_no, fname, lname, house_no, street, city, state, phone, email)
	VALUES(:new_customer);
	EXEC SQL COMMIT;

	printf("New customer successfully added\n");
}

// Query 2
// Completed
void delete_employee(){
	int e_no;
	
	printf("Enter employee_no >> ");
	scanf("%d", &e_no);

	EXEC SQL DELETE FROM Employees
	WHERE employee_no = :e_no;
	EXEC SQL COMMIT;

	printf("Employee successfully deleted\n");	
}

// Query 3
void update_order_description(){
	int o_no;

	printf("Enter order_no >> ");
	scanf("%d", &o_no);
	printf("Enter new description >> ");
	
	/* Incomplete */
}

// Query 4
void show_orders_by_vehicle(){
	struct order *order_recv;
	char v[20];
	
	if((order_recv = (struct order *) malloc(sizeof(struct order))) == 0){
		fprintf(stderr, "Memory allocation error\n");
		exit(EXIT_FAILURE);
	} 

	printf("Enter vin >> ");
	scanf("%s", v);
	
	EXEC SQL DECLARE vehicle_orders CURSOR FOR
		SELECT * 
			FROM Orders
			WHERE vin = :v
			ORDER BY start_date;

	EXEC SQL OPEN vehicle_orders;

	/* Table header */
	printf("order_no              start_date  end_date  \n");
	printf("--------------------  ----------  ----------\n");

	EXEC SQL WHENEVER NOT FOUND DO break;

	while(1){
		EXEC SQL FETCH vehicle_orders INTO :order_recv;
		printf("%-20s  %-10s  %-10s\n",
			order_recv -> order_no,
			order_recv -> start_date,
			order_recv -> end_date);
	}
	
	EXEC SQL CLOSE vehicle_orders;
}

// Query 5
void show_line_items(){
	struct item item_recv;
	int o_no;

	printf("Enter order_no >> ");
	scanf("%d", &o_no);

	EXEC SQL DECLARE line_items CURSOR FOR
		SELECT * 
			FROM Items
			WHERE order_no = (
				SELECT order_no
				FROM Invoices
				WHERE order_no = :o_no);

	EXEC SQL OPEN line_items;	

	EXEC SQL WHENEVER NOT FOUND DO break;

	/* Table header */
	printf("item_no         procedure_no  description                 cost\n");
	printf("--------------  ------------  --------------------------  ----------\n");

	while(1){
		EXEC SQL FETCH line_items INTO :item_recv;
		printf("%-13d  %-13d  %-20s  %-10d\n", 
			item_recv.item_no,
			item_recv.procedure_no,
			item_recv.description,
			item_recv.cost);
	}
	
	EXEC SQL CLOSE line_items;
}


// Query 6
void show_orders_by_date(){
	struct order *order_recv;

	if((order_recv = (struct order *) malloc(sizeof(struct order))) == 0){
                fprintf(stderr, "Memory allocation error\n");
                exit(EXIT_FAILURE);
        }


	EXEC SQL DECLARE orders CURSOR FOR
		SELECT * 
			FROM Orders
			WHERE start_date >= 20050601 
			AND end_date <= 20051231
			ORDER BY order_no;

	EXEC SQL OPEN orders;

	// Table header
        printf("order_no  \n");

	EXEC SQL WHENEVER NOT FOUND DO break;
	
	while(1){
		EXEC SQL FETCH orders INTO :order_recv;
		printf("%d\n", 
			order_recv -> order_no);
	}

	EXEC SQL CLOSE orders;
}

// Query 7
void items_by_procedure(){
	struct item item_recv;
	int o_no;
	int p_no;

	printf("Enter order_noo >> ");
	scanf("%d", &o_no);
	printf("Enter procedure_no >> ");
	scanf("%d", &p_no);
	
	EXEC SQL DECLARE items CURSOR FOR
		SELECT * 
			FROM Items
			WHERE procedure_no = :p_no
			AND order_no = :o_no;

	EXEC SQL WHENEVER NOT FOUND DO break;

	// Table header 
	printf("\n");
	printf("\n");
}

// Query 8
void all_procedures_by_order(){

}

// Query 9
void employee_invoices(){

}

// Query 10
void invoice_details(){

}

void main(){ 
	/* Connect to Oracle */ 
	strcpy(username, "abk89"); 
	strcpy(password, "~Ece3038");
	
	EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error: ");
 
	EXEC SQL CONNECT :username IDENTIFIED BY :password; 
	printf("\nConnected to Oracle as user: %s\n", username); 
 
	main_menu();

	while(1){
		int inp;
		printf(">> ");
		scanf("%d", &inp);

		switch(inp){
			case 0:
				printf("Program finished!\n");
				EXEC SQL COMMIT WORK RELEASE;
				exit(EXIT_SUCCESS);

			case 1:
				add_customer();
				break;
		
			case 2:
				delete_employee();
				break;

			case 3: 
				update_order_description();
				break;

			case 4:
				show_orders_by_vehicle();
				break;

			case 5:
				show_line_items();				
				break;

			case 6:
				show_orders_by_date();
				break;

			case 7:
				items_by_procedure();
				break;
			
			case 8:
				all_procedures_by_order();
				break;
		
			case 9: 
				employee_invoices();
				break;

			case 10:
				invoice_details();
				break;

			default:	
				printf("Invalid input \"%d\", please try again\n", inp);
				break;
		}
	}
}
